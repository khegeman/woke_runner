

# Woke Runner 

Currently, Woke mixes the running of fuzz tests with the randomization of the flows to create a sequence.  This makes it somewhat difficult to extend Woke to support features like replaying sequences of flows from a file.. 

This repository, contains an experimental, alternative design where there is a simple run method that takes an Iterable over a sequence of flows - the generator of this iterable returns the name of the flow as well as provide the input values to call the flow.  


In pseudo code, something like this.  Where the sequence of flows can be generated by a randomized process like FuzzTest::run currently does.  Alteratively, the sequence can be created from flows recorded to a file or the sequence can be fixed 

The existing FuzzTest from Woke can be used as is.  

# Example Contract

``` solidity
contract Bank {
   event Deposit(address indexed account, uint256 amount);
   event Withdraw(address indexed account, uint256 amount);


   mapping (
    address => uint256) public accounts;

  function deposit(uint256 amount) public {
  	accounts[msg.sender]+=amount;
   emit Deposit(msg.sender,amount);

  }
  	
  function withdraw(uint256 amount) public {
  	accounts[msg.sender] -= amount;
   emit Withdraw(msg.sender,amount);

  }

}
```

# Example Flows

``` python

@dataclass
class BankInput:
    user: Account
    amount: int

class BankTest(FuzzTest):

    def bank_input(self) -> BankInput:
        return BankInput(
            user=st.choose(self.accounts)(),
            amount=st.random_int(0, 50, edge_values_prob=0.05)(),
        )

    bank: Bank

    def pre_sequence(self) -> None:
        """
        Set up the pre-sequence for the fuzz test.
        """
        self._bank = Bank.deploy(from_=default_chain.accounts[0])
  
        self.accounts = list()
        self.accounts.extend(default_chain.accounts[1:5])

    @flow()
    def deposit(self, bank_input: BankInput) -> None:

        balance = self._bank.accounts(bank_input.user)
        overflow = balance + bank_input.amount > MAX_UINT
        try:
            tx = self._bank.deposit(bank_input.amount, from_=bank_input.user)
            assert balance + bank_input.amount == self._bank.accounts(
                bank_input.user
            )
            assert not overflow
        except Panic as e:
            assert e.code == PanicCodeEnum.UNDERFLOW_OVERFLOW
            assert overflow

    @flow()
    def withdraw(self, bank_input: BankInput) -> None:

        balance = self._bank.accounts(bank_input.user)
        underflow = balance < bank_input.amount
        try:
            tx = self._bank.withdraw(bank_input.amount, from_=bank_input.user)
            assert not underflow
            assert balance - bank_input.amount == self._bank.accounts(
                bank_input.user
            )
        except Panic as e:
            assert e.code == PanicCodeEnum.UNDERFLOW_OVERFLOW
            assert underflow


```


# Unit Tests 
Let's say we have a unit test like this in woke for a simple Bank contract. 

``` python 
@default_chain.connect()
def test_deposit():
    user_addr = "0x15d34aaf54267db7d7c367839aaf71a00a2c6a65"
    # setup
    bank = Bank.deploy(from_=default_chain.accounts[0])
    bank.deposit(amount = 2, from_=Account(user_addr))

    assert bank.accounts(user_addr)==2
```

This simple example can be emulated with the following usis this framework.  This makes use of the setup and property tests of the deposit flow.

``` python 
@default_chain.connect()
def test_deposit():
    bt = BankTest()
    unit_test(
        bt,
        flow_name="deposit",
        params={"bank_input": BankInput(user=Account(user_addr), amount=2)}
    )
```

# Fuzz Tests

A fuzz test of just the deposit method can also be run with a similar setup.  This test will call deposit 10 times with randomized inputs.  Each time, it will call the `pre_sequence` method on BankTest to setup the contracts and state.  This is not a stateful test. 

``` python
@default_chain.connect()
def test_deposit():

    bt = BankTest()

    fuzz_test(bt, sequences_count=10, flow_name="deposit")
```
# Stateful Fuzz Tests
A stateful fuzz test where the order of the flows is randomized and the state persists between calls .  This is equivalent to the standard `run` method on the woke FuzzTest class.

``` python
@default_chain.connect()
def test_fuzz():

    bt = BankTest()

    stateful_test(bt, sequence_count=10, flow_count=5)

```
